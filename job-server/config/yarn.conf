spark {
  # spark.master will be passed to each job's JobContext
  master = "yarn-client"
  # master = "mesos://vm28-hulk-pub:5050"
  # master = "yarn-client"

  # Default # of CPUs for jobs to use for Spark standalone cluster
  job-number-cpus = 4

  jobserver {
    port = 8090
    jar-store-rootdir = /usr/local/spark-job-server/jars

    context-per-jvm = true

    jobdao = spark.jobserver.io.JobFileDAO

    filedao {
      rootdir = /usr/local/spark-job-server/data
    }
  }

  # universal context configuration.  These settings can be overridden, see README.md
  context-settings {
    # choose a port that is free on your system and also the 16 (depends on max retries for submitting the job) next portnumbers should be free
    spark.driver.port = 32456 # important
    # defines the place where your spark-assembly jar is located in your hdfs
    #spark.yarn.jar = "hdfs://scdh56-master.staging.xpatterns.com:8020/user/alinb/spark_jars/spark-assembly-1.6.0-hadoop2.6.0.jar"

    num-cpu-cores = 2           # Number of cores to allocate.  Required.
    memory-per-node = 512m         # Executor memory per node, -Xmx style eg 512m, #1G, etc.

    # in case spark distribution should be accessed from HDFS (as opposed to being installed on every mesos slave)
    # spark.executor.uri = "hdfs://namenode:8020/apps/spark/spark.tgz"

    # uris of jars to be loaded into the classpath for this context. Uris is a string list, or a string separated by commas ','
    # dependent-jar-uris = ["file:///some/path/present/in/each/mesos/slave/somepackage.jar"]

    # If you wish to pass any settings directly to the sparkConf as-is, add them here in passthrough,
    # such as hadoop connection settings that don't use the "spark." prefix
    passthrough {
      #es.nodes = "192.1.1.1"
    }
  }

  # This needs to match SPARK_HOME for cluster SparkContexts to be created successfully
  home = "/usr/local/spark"
}

# Note that you can use this file to define settings not only for job server,
# but for your Spark jobs as well.  Spark job configuration merges with this configuration file as defaults.

akka {
  remote.netty.tcp {
    # This controls the maximum message size, including job results, that can be sent
    # maximum-frame-size = 10 MiB
  }
}
# check the reference.conf in spray-can/src/main/resources for all defined settings
spray.can.server {
  # uncomment the next line for making this an HTTPS example
  # ssl-encryption = on
  idle-timeout = 240 s
  request-timeout = 200 s
  pipelining-limit = 2 # for maximum performance (prevents StopReading / ResumeReading messages to the IOBridge)
  # Needed for HTTP/1.0 requests with missing Host headers
  #default-host-header = "spray.io:8765"
  parsing.max-content-length = 400m
}

shiro {
  # activate authentication (and authorization)
  authentication = on
  # absolute path to shiro config file, including file name
  config.path = "/usr/local/spark-job-server/shiro.ini"
  # note that ssl-encryption should also be on when authentication is on to avoid that passwords
  # can be sniffed out
  # Time out for job server to wait for authentication requests
  authentication-timeout = 10 s
}

#deploy {
#  manager-start-cmd = "./manager_start.sh luciant"
#   }